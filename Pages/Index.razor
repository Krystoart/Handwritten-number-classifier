@page "/"
@inject IJSRuntime jsRuntime
@using Microsoft.AspNetCore.Components.Web;
@using System.Text.RegularExpressions;
@using System.Drawing;
@using System.Drawing.Imaging;
@using System.IO;
@using MnistClassificator

<link href='https://fonts.googleapis.com/css?family=Montserrat' rel='stylesheet'>
<header>
    <h1>Written number classifier</h1>
</header>
<div class="content" @onmousemove="@MouseIsOutOfSvg">
    <canvas id="mainCanvas" width="28" height="28">
    </canvas>
    <div class="canvas">
        <svg id="mainSvg" class="svg" width="@CanvasWidth" height="@CanvasHeight"
            @onmousedown="@OnMouseDown" @onmousemove="@OnMouseMove" @onmouseup="@OnMouseUp">
            @if(polylinesHistoric.Capacity > 0){
                @foreach (var polyline in polylinesHistoric)
                {
                    @polyline
                }
            }
            @polylineCurrent
        </svg>
        <div class="svgButtons">
            <button @onclick="@ClearDrawing" class="button">
                Clear
            </button>
            <button @onclick="@ClearLast" class="button">
                Undo
            </button>
            <button @onclick="@GuessImage" class="button">
                Guess
            </button>
            <button class="button" @onclick="@SaveSvg">
                Save
            </button>
        </div>
    </div>
    <div class="canvas" style="width:340px">
        <div class="history">
            @if(guesses.Count > 0){
                @for(int i=0; i<guesses.Count(); i++)
                {
                    <label>
                        <input type="radio" name="guess" @onclick="(e) => GetSelection(i-1, e)">
                        <div class="guessed">
                            @guesses[i]
                        <div class="results">
                            @for(int j=0; j<guessValues[i].Count(); j++)
                            {
                                <div>@guessValues[i][j]</div>
                            }
                        </div>
                        </div>
                    </label>
                }
            }
        </div>
        <div style="display:flex;flex-direction:row;margin:1em">
            <button class="button" @onclick="@DeleteSelection">
                Delete
            </button>
        </div>
    </div>
</div>

@code {
    public string PointString;
    public double CanvasWidth;
    public double CanvasHeight;
    private bool pressed;
    private string Y;
    private string X;
    private bool mouseIsOutOfSvg;
    private string hrefString;

    private int selectedItemIndex;

    private byte[] bytes;
    private List<string> scaledCurrentDrawingAsString = new List<string>();
    private List<RenderFragment> guesses = new List<RenderFragment>();
    private List<List<string>> guessValues = new List<List<string>>();
    private List<RenderFragment> polylinesHistoric = new List<RenderFragment>();
    private RenderFragment polylineCurrent;

    private Classificator mnistClassificator = new Classificator();

    protected override void OnInitialized()
    {
        PointString = "";
        CanvasWidth = 500;
        CanvasHeight = 500;
        pressed = false;
    }
    protected async void OnMouseDown(MouseEventArgs e)
    {
        await SetCoordinates(e);
        PointString = X;
        pressed = true;

        polylineCurrent = CreateComponent();
    }
    protected void OnMouseUp(MouseEventArgs e)
    {
        pressed = false;
        polylinesHistoric.Add(CreateComponentStatic(PointString, "26"));
        scaledCurrentDrawingAsString.Add(Scale(PointString, (Double)0.2));
    }

    protected async void MouseIsOutOfSvg(MouseEventArgs e)
    {
        mouseIsOutOfSvg = await jsRuntime.InvokeAsync<bool>("MouseIsOutOfSvg", e);
    }

    protected void GetSelection(int itemIndex,MouseEventArgs e)
    {
        selectedItemIndex = itemIndex;
    }

    protected void DeleteSelection(MouseEventArgs e)
    {
        if(selectedItemIndex > -1)
        {
            guesses.RemoveAt(selectedItemIndex);
            guessValues.RemoveAt(selectedItemIndex);

        }
    }

    protected async void SaveSvg(MouseEventArgs e)
    {
        await jsRuntime.InvokeAsync<string>("SaveSvg");
        hrefString = await jsRuntime.InvokeAsync<string>("getBase64");
        if(!String.IsNullOrEmpty(hrefString)){
            string toRemove = "data:image/png;base64,";
            string testString = hrefString.Replace(toRemove, "");
            bytes = Convert.FromBase64String(testString);
            saveFile(bytes);
        } else{
            SaveSvg(e);
        }
    }

    public void saveFile(byte[] imageBytes)
    {
        FileStream file = new FileStream("./number.png", FileMode.Create, FileAccess.Write);
        StreamWriter m_WriterParameter = new StreamWriter(file);
        MemoryStream ms = new MemoryStream(imageBytes);
        ms.WriteTo(file);
        file.Close();
        ms.Close();
    }

    protected async void OnMouseMove(MouseEventArgs e)
    {
        if(!pressed)return;
        await SetCoordinates(e);
        PointString = PointString + "," + Y + " " + X;
        if(mouseIsOutOfSvg)
        {
            OnMouseUp(e);
        }
    }

    protected async Task SetCoordinates(MouseEventArgs e)
    {

        var Coordinates = await jsRuntime.InvokeAsync<string>("accessDOMElement", e);
        X = Coordinates.Split(" ")[0];
        Y = Coordinates.Split(" ")[1];
    }

    protected void ClearDrawing()
    {
        polylinesHistoric.Clear();
        scaledCurrentDrawingAsString.Clear();
        polylineCurrent = null;
    }

    protected void ClearLast(MouseEventArgs e)
    {
        if (polylinesHistoric.Count > 0)
            polylinesHistoric.RemoveAt(polylinesHistoric.Count() - 1);
        polylineCurrent = null;
    }

    private RenderFragment CreateComponent() => builder =>
    {
        builder.OpenElement(1, "polyline");
        builder.AddAttribute(2, "points", PointString);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke-width", "26");
        builder.AddAttribute(5, "stroke", "black");
        builder.CloseElement();
    };

    private RenderFragment CreateComponentStatic(string points, string strokeWidth) => builder =>
    {
        builder.OpenElement(1, "polyline");
        builder.AddAttribute(2, "points", points);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke-width", strokeWidth);
        builder.AddAttribute(5, "stroke", "black");
        builder.CloseElement();
    };

    protected async void GuessImage()
    {
        await jsRuntime.InvokeAsync<string>("SaveSvg");
        hrefString = await jsRuntime.InvokeAsync<string>("getBase64");
        if(scaledCurrentDrawingAsString.Count() > 0 && !String.IsNullOrEmpty(hrefString))
        {
            var item = new List<RenderFragment>();
            scaledCurrentDrawingAsString.ForEach(x => item.Add(CreateComponentStatic(x, "9")));
            RenderFragment svg = CreateSvg(item);
            guesses.Insert(0, svg);

            string toRemove = "data:image/png;base64,";
            string testString = hrefString.Replace(toRemove, "");
            bytes = Convert.FromBase64String(testString);

            Bitmap bmp;
            using (var ms = new MemoryStream(bytes))
            {
                bmp = new Bitmap(ms);
            }

            bmp.RotateFlip(RotateFlipType.Rotate90FlipX);

            byte[] image = new byte[ bmp.Width * bmp.Height];

            // Some preprocessing is done here
            // It reduces the dimensions from 2d to 1d
            int counter = 0;
            for(int x=0; x<bmp.Width; x++)
            {
                for(int y=0; y<bmp.Height; y++)
                {
                    byte temp = bmp.GetPixel(x, y).A;
                    if(temp > 0)
                        image[counter] = 255;
                    else
                        image[counter] = 0;
                    counter += 1;
                }
            }

            // Makes a call to the model and returns an array of values float[]
            var digitAnalyze = mnistClassificator.Analyze(image);

            List<string> results = new List<string>();
            for(int n=0; n<10; n++)
            {
                results.Add($"{n}: {digitAnalyze[n] * 100:0.##}%");
            }
            guessValues.Insert(0, results);

            /*
            // For testing purposes prints the values in the console
            for(int b=0; b<10; b++)
            {
                Console.Write($"{b} {digitAnalyze[b]:0.####}");
                Console.WriteLine();
            }
            Console.WriteLine();

            // For testing also prints the number array
            for(int x=0; x<bmp.Width * bmp.Height; x++)
            {
                Console.Write(image[x]);
                Console.Write(' ');
                if (x % 28 == 0)
                    Console.WriteLine();
            }
            Console.WriteLine();
            */

            // Clear drawings
            scaledCurrentDrawingAsString.Clear();
            polylinesHistoric.Clear();
            polylineCurrent = null;
            await jsRuntime.InvokeAsync<string>("ClearMainCanvas");
        }
        else
        {
            GuessImage();
        }
    }

    private RenderFragment CreateSvg(List<RenderFragment> polylines) => builder =>
    {
        int index = 0;
        builder.OpenElement(index++, "svg");
        builder.AddAttribute(index++, "viewBox", "0 0 100 100");
        builder.AddAttribute(index++, "preserveAspectRatio", "xMin meet");
        foreach (RenderFragment polyline in polylines)
        {
            builder.AddContent(index++, polyline);
        }
        builder.CloseElement();
    };

    private string Scale(string pointsToRescale, double scale){
        string[] splittedPoints = pointsToRescale.Split(',');
        string newPoints = "";
        foreach(string point in splittedPoints)
        {
            if(Regex.Match(point, @"\d+\s\d+").Success)
            {
                string[] pair = point.Split(" ");
                Double x = Double.Parse(pair[0]);
                Double y = Double.Parse(pair[1]);
                x *= scale;
                y *= scale;
                newPoints += "," + x.ToString() + " " + y.ToString();
            }
            else
            {
                Double p = Double.Parse(point);
                p *= scale;
                newPoints+= p.ToString();
            }
        }
        return newPoints;
    }
}
