@page "/"
@inject IJSRuntime jsRuntime
@using Microsoft.AspNetCore.Components.Web;
@using System.Text.RegularExpressions;
@using System.Drawing;
@using System.Drawing.Imaging;
@using System.IO;
@using MnistClassificator

<h1>WRITTEN NUMBER CLASSIFIER</h1>
<div class="content" @onmousemove="@MouseIsOutOfSvg">
    <canvas id="mainCanvas" width="28" height="28">

    </canvas>
    <a download="FILENAME.EXT" href="@hrefString">download</a>
    <div class="canvas">
        <svg id="mainSvg" class="svg" width="@CanvasWidth" height="@CanvasHeight"
            @onmousedown="@OnMouseDown" @onmousemove="@OnMouseMove" @onmouseup="@OnMouseUp">
            @if(polylinesHistoric.Capacity > 0){
                @foreach (var polyline in polylinesHistoric)
                {
                    @polyline
                }
            }
            @polylineCurrent
        </svg>
        <div style="display:flex;flex-direction:row;margin:1em">
            <button @onclick="@ClearDrawing" class="button">
                Clear
            </button>
            <button @onclick="@ClearLast" class="button">
                Back
            </button>
            <button @onclick="@GuessImage" class="button">
                Guess
            </button>
        </div>
    </div>
    <div class="canvas">
        <div class="history">
            @if(guesses.Capacity > 0){
                @foreach (var guess in guesses)
                {
                    <div class="guessed">
                        @guess
                    </div>
                }
            }
        </div>
        <div style="display:flex;flex-direction:row;margin:1em">
            <button class="button" @onclick="@SaveSvg">
                Save
            </button>
            @* <button class="button">
                Edit
            </button> *@
            <button class="button">
                Delete
            </button>
        </div>
    </div>
</div>

@code {
    public string PointString;
    public double CanvasWidth;
    public double CanvasHeight;
    private bool pressed;
    private string Y;
    private string X;
    private bool mouseIsOutOfSvg;
    private string hrefString;

    private byte[] bytes;
    private List<string> scaledCurrentDrawingAsString = new List<string>();
    private List<RenderFragment> guesses = new List<RenderFragment>();
    private List<RenderFragment> polylinesHistoric = new List<RenderFragment>();
    private RenderFragment polylineCurrent;

    protected override void OnInitialized()
    {
        PointString = "";
        CanvasWidth = 500;
        CanvasHeight = 500;
        pressed = false;
    }
    protected async void OnMouseDown(MouseEventArgs e)
    {
        await SetCoordinates(e);
        PointString = X;
        pressed = true;

        polylineCurrent = CreateComponent();
    }
    protected void OnMouseUp(MouseEventArgs e)
    {
        pressed = false;
        polylinesHistoric.Add(CreateComponentStatic(PointString));
        scaledCurrentDrawingAsString.Add(ScaleDown(PointString));
    }

    protected async void MouseIsOutOfSvg(MouseEventArgs e)
    {
        mouseIsOutOfSvg = await jsRuntime.InvokeAsync<bool>("MouseIsOutOfSvg", e);
    }

    protected async void SaveSvg(MouseEventArgs e)
    {
        await jsRuntime.InvokeAsync<string>("SaveSvg");
        hrefString = await jsRuntime.InvokeAsync<string>("getBase64");
        if(!String.IsNullOrEmpty(hrefString)){
            string toRemove = "data:image/png;base64,";
            string testString = hrefString.Replace(toRemove, "");
            bytes = Convert.FromBase64String(testString);
            saveFile(bytes);

            @* Bitmap bmp;
            using (var ms = new MemoryStream(bytes))
            {
                bmp = new Bitmap(ms);
            }

            bmp.RotateFlip(RotateFlipType.Rotate90FlipX);

            for(int x=0; x<bmp.Width; x++)
            {
                for(int y=0; y<bmp.Height; y++)
                {
                    Console.Write(bmp.GetPixel(x, y).A);
                    Console.Write(' ');
                }
                Console.WriteLine();
            } *@
        }
    }

    public void saveFile(byte[] imageBytes)
    {
        FileStream file = new FileStream("./number.png", FileMode.Create, FileAccess.Write);
        StreamWriter m_WriterParameter = new StreamWriter(file);
        MemoryStream ms = new MemoryStream(imageBytes);
        ms.WriteTo(file);
        file.Close();
        ms.Close();
    }

    protected async void OnMouseMove(MouseEventArgs e)
    {
        if(!pressed)return;
        await SetCoordinates(e);
        PointString = PointString + "," + Y + " " + X;
        if(mouseIsOutOfSvg)
        {
            OnMouseUp(e);
        }
    }

    protected async Task SetCoordinates(MouseEventArgs e)
    {
        var Coordinates = await jsRuntime.InvokeAsync<string>("accessDOMElement", e);
        X = Coordinates.Split(" ")[0];
        Y = Coordinates.Split(" ")[1];
    }

    protected void ClearDrawing()
    {
        polylinesHistoric.Clear();
        scaledCurrentDrawingAsString.Clear();
        polylineCurrent = null;
    }

    protected void ClearLast(MouseEventArgs e)
    {
        if (polylinesHistoric.Count > 0)
            polylinesHistoric.RemoveAt(polylinesHistoric.Count() - 1);
        polylineCurrent = null;
    }

    private RenderFragment CreateComponent() => builder =>
    {
        builder.OpenElement(1, "polyline");
        builder.AddAttribute(2, "points", PointString);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke-width", "40");
        builder.AddAttribute(5, "stroke", "black");
        builder.CloseElement();
    };

    private RenderFragment CreateComponentStatic(string points) => builder =>
    {
        builder.OpenElement(1, "polyline");
        builder.AddAttribute(2, "points", points);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke-width", "40");
        builder.AddAttribute(5, "stroke", "black");
        builder.CloseElement();
    };

    protected void GuessImage()
    {
        if(scaledCurrentDrawingAsString.Count() > 0)
        {
            var item = new List<RenderFragment>();
            scaledCurrentDrawingAsString.ForEach(x => item.Add(CreateComponentStatic(x)));
            RenderFragment svg = CreateSvg(item);
            guesses.Add(svg);

            // Clear drawings
            scaledCurrentDrawingAsString.Clear();
            polylinesHistoric.Clear();
            polylineCurrent = null;
        }
    }

    private RenderFragment CreateSvg(List<RenderFragment> polylines) => builder =>
    {
        int index = 0;
        builder.OpenElement(index++, "svg");
        builder.AddAttribute(index++, "viewBox", "0 0 100 100");
        builder.AddAttribute(index++, "preserveAspectRatio", "xMin meet");
        foreach (RenderFragment polyline in polylines){
            builder.AddContent(index++, polyline);
        }
        builder.CloseElement();
    };

    private string ScaleDown(string pointsToRescale){
        string[] splittedPoints = pointsToRescale.Split(',');
        string newPoints = "";
        foreach(string point in splittedPoints){
            if(Regex.Match(point, @"\d+\s\d+").Success){
                string[] pair = point.Split(" ");
                Double x = Double.Parse(pair[0]);
                Double y = Double.Parse(pair[1]);
                x *= 0.2;
                y *= 0.2;
                newPoints += "," + x.ToString() + " " + y.ToString();
            }
            else{
                Double p = Double.Parse(point);
                p *= 0.2;
                newPoints+= p.ToString();
            }
        }
        return newPoints;
    }
}
