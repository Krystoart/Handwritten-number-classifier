@page "/"
@inject IJSRuntime jsRuntime
@using Microsoft.AspNetCore.Components.Web;
@using System.Text.RegularExpressions;

<h1>WRITTEN NUMBER CLASSIFIER</h1>
<div class="content" @onmousemove="@MouseIsOutOfSvg">
    <div class="canvas">
        <svg id="mainSvg" class="svg" width="@CanvasWidth" height="@CanvasHeight"
            @onmousedown="@OnMouseDown" @onmousemove="@Mouse_Move" @onmouseup="@OnMouseUp">
            @if(polylinesHistoric.Capacity > 0){
                @foreach (var polyline in polylinesHistoric)
                {
                    @polyline
                }
            }
            @polylineCurrent
        </svg>
        <div style="display:flex;flex-direction:row;margin:1em">
            <button @onclick="@ClearDrawing" class="button">
                Clear
            </button>
            <button @onclick="@ClearLast" class="button">
                Back
            </button>
            <button @onclick="@GuessImage" class="button">
                Guess
            </button>
        </div>
    </div>
    <div class="canvas">
        <div class="history">
            @if(guesses.Capacity > 0){
                @foreach (var guess in guesses)
                {
                    <div class="guessed">
                        @guess
                    </div>
                }
            }
        </div>
        <div style="display:flex;flex-direction:row;margin:1em">
            <button class="button">
                Save
            </button>
            <button class="button">
                Edit
            </button>
            <button class="button">
                Delete
            </button>
        </div>
    </div>
</div>

@code {
    public string PointString;
    public double CanvasWidth;
    public double CanvasHeight;
    private bool pressed;
    private string Y;
    private string X;
    private bool mouseIsOutOfSvg;

    private List<string> scaledCurrentDrawingAsString = new List<string>();
    private List<RenderFragment> guesses = new List<RenderFragment>();
    private List<RenderFragment> polylinesHistoric = new List<RenderFragment>();
    private RenderFragment polylineCurrent;

    protected override void OnInitialized()
    {
        PointString = "";
        CanvasWidth = 500;
        CanvasHeight = 500;
        pressed = false;
    }
    protected async void OnMouseDown(MouseEventArgs e)
    {
        await SetCoordinates(e);
        PointString = X;
        pressed = true;

        polylineCurrent = CreateComponent();
    }
    protected void OnMouseUp(MouseEventArgs e)
    {
        pressed = false;
        polylinesHistoric.Add(CreateComponentStatic(PointString));
        scaledCurrentDrawingAsString.Add(ScaleDown(PointString));
    }

    protected async void MouseIsOutOfSvg(MouseEventArgs e)
    {
       mouseIsOutOfSvg = await jsRuntime.InvokeAsync<bool>("MouseIsOutOfSvg", e);
    }

    protected async void Mouse_Move(MouseEventArgs e)
    {
        if(!pressed)return;
        await SetCoordinates(e);
        PointString = PointString + "," + Y + " " + X;
        if(mouseIsOutOfSvg)
        {
            OnMouseUp(e);
        }
    }

    protected async Task SetCoordinates(MouseEventArgs e)
    {
        var Coordinates = await jsRuntime.InvokeAsync<string>("accessDOMElement", e);
        X = Coordinates.Split(" ")[0];
        Y = Coordinates.Split(" ")[1];
    }

    protected void ClearDrawing()
    {
        polylinesHistoric.Clear();
        scaledCurrentDrawingAsString.Clear();
        polylineCurrent = null;
    }

    protected void ClearLast(MouseEventArgs e)
    {
        polylinesHistoric.RemoveAt(polylinesHistoric.Count() - 1);
        polylineCurrent = null;
    }

     private RenderFragment CreateComponent() => builder =>
    {
        builder.OpenElement(1, "polyline");
        builder.AddAttribute(2, "points", PointString);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke-width", "4");
        builder.AddAttribute(5, "stroke", "black");
        builder.CloseElement();
    };

     private RenderFragment CreateComponentStatic(string points) => builder =>
    {
        builder.OpenElement(1, "polyline");
        builder.AddAttribute(2, "points", points);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke-width", "4");
        builder.AddAttribute(5, "stroke", "black");
        builder.CloseElement();
    };

    protected void GuessImage()
    {
        var item = new List<RenderFragment>();
        scaledCurrentDrawingAsString.ForEach(x => item.Add(CreateComponentStatic(x)));
        RenderFragment svg = CreateSvg(item);
        guesses.Add(svg);

        // Clear drawings
        scaledCurrentDrawingAsString.Clear();
        polylinesHistoric.Clear();
        polylineCurrent = null;
    }

     private RenderFragment CreateSvg(List<RenderFragment> polylines) => builder =>
    {
        int index = 0;
        builder.OpenElement(index++, "svg");
        builder.AddAttribute(index++, "viewBox", "0 0 100 100");
        builder.AddAttribute(index++, "preserveAspectRatio", "xMin meet");
        foreach (RenderFragment polyline in polylines){
            builder.AddContent(index++, polyline);
        }
        builder.CloseElement();
    };

    private string ScaleDown(string pointsToRescale){
        string[] splittedPoints = pointsToRescale.Split(',');
        string newPoints = "";
        foreach(string point in splittedPoints){
            if(Regex.Match(point, @"\d+\s\d+").Success){
                string[] pair = point.Split(" ");
                Double x = Double.Parse(pair[0]);
                Double y = Double.Parse(pair[1]);
                x *= 0.2;
                y *= 0.2;
                newPoints += "," + x.ToString() + " " + y.ToString();
            }
            else{
                Double p = Double.Parse(point);
                p *= 0.2;
                newPoints+= p.ToString();
            }
        }
        return newPoints;
    }
}
